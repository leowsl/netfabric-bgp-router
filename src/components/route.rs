use ip_network::IpNetwork;
use serde::{Deserialize, Serialize};
use std::net::{IpAddr, Ipv4Addr};
use crate::components::bgp::bgp_bestroute::BestRoute;


#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PathElement {
    ASN(u64),
    ASSet(Vec<u64>),
}
pub type Path = Vec<PathElement>;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Route {
    pub peer: IpAddr,
    pub prefix: IpNetwork,
    pub next_hop: String,
    pub as_path: Path,
}

impl Route {
    pub fn new() -> Self {
        Default::default()
    }

    pub fn is_default(&self) -> bool {
        self == &Route::default()
    }
}

impl Default for Route {
    fn default() -> Self {
        Route {
            peer: IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
            prefix: IpNetwork::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap(),
            next_hop: "".to_string(),
            as_path: Path::new(),
        }
    }
}

impl From<BestRoute> for Route {
    fn from(best_route: BestRoute) -> Self {
        best_route.0
    }
}

impl PartialOrd for Route {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        // Cisco Weight
        // Local Preference
        // Generated by this router
        // K체rzestes AS Path attr
        if self.as_path.len() != other.as_path.len() {
            return Some(self.as_path.len().cmp(&other.as_path.len()).reverse());
        };
        // Niedrigster origin typ IBG < EBGP < Incomplete
        // niedristes MED attribut
        // externe 체ber interne
        // n채chstgelegenr IGP Nachbar
        // niedrigste Peer Ip bez체glich der Router-ID
        if self.peer != other.peer {
            return Some(self.peer.cmp(&other.peer));
        };
        // log::error!("Unable to compute bestroute between {:?} and {:?}", a, b);
        // TODO: In the current state of the network, it can happen that we have two similiar routes. 
        // So we choosethe first one as tiebreaker, hoping that it wont collide
        return None
    }
}

impl Ord for Route {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match self.partial_cmp(other) {
            Some(ordering) => ordering,
            None => std::cmp::Ordering::Equal,
        }
    }
}

